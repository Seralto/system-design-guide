{
  "nav": {
    "title": "System Design Guide",
    "fundamentals": "Fundamentals of System Design",
    "systemDesignFramework": "System Design Framework",
    "architecture": "Architecture",
    "scalability": "Scalability", 
    "communication": "Communication",
    "async": "Async Patterns",
    "performance": "Performance",
    "security": "Security"
  },
  "topics": {
    "loadBalancers": "Load Balancers",
    "appServers": "Application Servers",
    "caching": "Caching",
    "databases": "Databases",
    "storage": "Storage",
    "replication": "Replication",
    "sharding": "Sharding",
    "cdn": "Content Delivery Network",
    "scalingTypes": "Scaling Types",
    "capTheorem": "CAP Theorem",
    "httpGrpc": "HTTP vs gRPC",
    "restGraphql": "REST vs GraphQL",
    "websockets": "WebSockets",
    "apiGateway": "API Gateway",
    "serviceMesh": "Service Mesh",
    "messageQueues": "Message Queues",
    "eventualConsistency": "Eventual Consistency",
    "eventSourcing": "Event Sourcing",
    "cqrs": "CQRS",
    "cachingPatterns": "Caching Patterns",
    "circuitBreaker": "Circuit Breaker",
    "retryTimeout": "Retry Logic & Timeouts",
    "observability": "Observability",
    "jwt": "JWT & OAuth2",
    "rateLimiting": "Rate Limiting",
    "tls": "TLS/HTTPS",
    "featureFlags": "Feature Flags",
    "deployment": "Deployment Strategies"
  },
  "sectionHeaders": {
    "keyPoints": "Key Points",
    "types": "Types",
    "patterns": "Patterns",
    "considerations": "Considerations",
    "learningTip": "Learning Tip",
    "whenToUse": "When to Use",
    "bestPractices": "Best Practices",
    "challenges": "Challenges",
    "benefits": "Benefits",
    "blobStorage": "Blob Storage",
    "storagePatterns": "Storage Patterns",
    "systemTypes": "System Types"
  },
  "homePage": {
    "title": "The Fundamentals of System Design",
    "subtitle": "A comprehensive guide to building scalable, reliable, and maintainable systems",
    "whatIsSystemDesign": {
      "title": "What is System Design?",
      "paragraph1": "System design is the process of defining the architecture, components, data flow, and interactions of a software system to meet specified goals. It involves making high-level decisions that balance trade-offs across performance, scalability, reliability, maintainability, cost, and complexity.",
      "paragraph2": "At its core, system design is about solving real-world problems through structured thinking, clear abstractions, and technical insight. Whether you're building a social media platform, an e-commerce website, or a real-time multiplayer game, system design ensures that your system can grow, adapt, and perform under load.",
      "paragraph3": "Unlike implementation, which focuses on isolated features, system design looks at the \"big picture\", how different parts of a system fit and work together. It's a collaborative and creative process that often starts long before the first line of code is written."
    },
    "keyQuestions": {
      "title": "System Design: 10 Key Questions",
      "intro": "A well-designed system must answer these ten fundamental questions. These questions help guide architectural decisions and prepare the system for scale, change, and resilience.",
      "questions": [
        {
          "number": 1,
          "title": "Scalability",
          "question": "How will the system handle increasing users, requests, and data volume efficiently?"
        },
        {
          "number": 2,
          "title": "Latency & Performance",
          "question": "How can we ensure low response times and consistent performance under load?"
        },
        {
          "number": 3,
          "title": "Fault Tolerance & Reliability",
          "question": "What happens when a component fails? Can the system detect, recover, and remain available?"
        },
        {
          "number": 4,
          "title": "Data Management",
          "question": "How should data be stored, retrieved, indexed, and cached to ensure integrity and performance?"
        },
        {
          "number": 5,
          "title": "Communication",
          "question": "How do system components interact, synchronously or asynchronously, and through what protocols (e.g., HTTP, gRPC, message queues)?"
        },
        {
          "number": 6,
          "title": "Security",
          "question": "How do we protect against unauthorized access, data leaks, and attacks like DDoS or injection?"
        },
        {
          "number": 7,
          "title": "Observability & Monitoring",
          "question": "How do we gain visibility into system health, errors, and usage patterns?"
        },
        {
          "number": 8,
          "title": "Compliance & Privacy",
          "question": "Are we meeting regulatory requirements (e.g., GDPR, HIPAA)? How are sensitive data secured and handled?"
        },
        {
          "number": 9,
          "title": "Maintainability & Extensibility",
          "question": "Can the system be easily debugged, monitored, updated, and expanded as requirements evolve?"
        },
        {
          "number": 10,
          "title": "Cost Efficiency",
          "question": "Are we balancing performance and reliability with infrastructure and operational costs?"
        }
      ]
    },
    "keyComponents": {
      "title": "Key Components of a Software System",
      "subtitle": "Understanding the Building Blocks",
      "intro": "A typical software system consists of several fundamental components, each contributing to the overall capability and resilience of the system:",
      "client": {
        "title": "1. Client / Frontend",
        "description": "The client is the interface through which users interact with the system (i.e., web browsers and mobile apps).",
        "responsibilities": "Responsibilities",
        "responsibilitiesList": [
          "Render the user interface (UI)",
          "Capture and validate user input",
          "Communicate with backend APIs (e.g., REST, GraphQL)"
        ]
      },
      "server": {
        "title": "2. Server / Backend",
        "description": "The backend powers the business logic and orchestrates system behavior.",
        "responsibilities": "Responsibilities",
        "responsibilitiesList": [
          "Process user requests",
          "Handle authentication and authorization",
          "Execute workflows and background tasks",
          "Communicate with databases and services"
        ],
        "patterns": "Common Patterns",
        "patternsList": [
          "Monolith",
          "Microservices",
          "Serverless"
        ]
      },
      "database": {
        "title": "3. Database / Storage",
        "description": "This component is responsible for persisting and managing data.",
        "intro": "Here are some common types:",
        "types": {
          "sql": {
            "title": "SQL",
            "examples": [
              "PostgreSQL/MySQL (structured data, transactions)"
            ]
          },
          "nosql": {
            "title": "NoSQL",
            "examples": [
              "MongoDB (flexible schema)",
              "Cassandra (high throughput)"
            ]
          },
          "inmemory": {
            "title": "In-memory",
            "examples": [
              "Redis/Memcached (fast caching)"
            ]
          },
          "objectStorage": {
            "title": "Object Storage",
            "examples": [
              "Amazon S3/GCP Storage (files and media blobs like images, videos, etc.)"
            ]
          }
        }
      },
      "networking": {
        "title": "4. Networking & Infrastructure Layer",
        "description": "This layer ensures secure and efficient communication across the system.",
        "types": {
          "loadBalancers": {
            "title": "Load balancers",
            "description": "Distribute traffic",
            "examples": [
              "HAProxy",
              "AWS ALB"
            ]
          },
          "apiGateways": {
            "title": "API gateways",
            "description": "Centralize request routing, auth, rate-limiting",
            "examples": [
              "Kong",
              "Amazon API Gateway"
            ]
          },
          "cdns": {
            "title": "CDNs",
            "description": "Cache static assets close to users",
            "examples": [
              "Cloudflare",
              "Akamai"
            ]
          },
          "serviceMesh": {
            "title": "Service mesh",
            "description": "Manage service-to-service communication in microservices",
            "examples": [
              "Istio",
              "Linkerd"
            ]
          }
        }
      },
      "thirdParty": {
        "title": "5. Third-Party & External Services",
        "description": "External services that provide specialized functionality to your system.",
        "types": {
          "authentication": {
            "title": "Authentication providers",
            "description": "Handle user identity and access",
            "examples": [
              "Auth0",
              "Firebase Auth",
              "Okta"
            ]
          },
          "payments": {
            "title": "Payment processors",
            "description": "Handle financial transactions",
            "examples": [
              "Stripe",
              "PayPal",
              "Square"
            ]
          },
          "notifications": {
            "title": "Notification services",
            "description": "Deliver messages across channels",
            "examples": [
              "Twilio",
              "SendGrid",
              "Firebase Cloud Messaging"
            ]
          },
          "monitoring": {
            "title": "Monitoring tools",
            "description": "Track system health and performance",
            "examples": [
              "Datadog",
              "New Relic",
              "Prometheus"
            ]
          },
          "ai": {
            "title": "AI/ML services",
            "description": "Add intelligence to applications",
            "examples": [
              "OpenAI API",
              "Google Cloud AI",
              "AWS Rekognition"
            ]
          }
        }
      }
    },
    "designProcess": {
      "title": "The System Design Process",
      "subtitle": "From Requirements to Blueprint",
      "intro": "Designing a system isn't a rigid checklist, it's an iterative process that evolves through exploration, validation, and refinement. Here's a proven step-by-step framework:",
      "steps": {
        "requirements": {
          "title": "1. Requirements Gathering",
          "description": "Understand what the system needs to accomplish.",
          "items": [
            "Functional Requirements: What should it do? (e.g., upload photos, send messages)",
            "Non-Functional Requirements (NFRs): Performance, latency, uptime, consistency",
            "User Modeling: Who are the users? What are their use cases and volume?",
            "Constraints: Tech stacks, budgets, SLAs, legal requirements"
          ]
        },
        "estimations": {
          "title": "2. Back-of-the-Envelope Estimations",
          "description": "Estimate scale to inform technology and architecture decisions:",
          "items": [
            "Storage Needs: GBs/TBs per day or per user",
            "Traffic Load: Peak QPS, reads vs. writes",
            "Network Bandwidth: Data transferred between users/services",
            "Server Count: Number of replicas needed to serve expected load"
          ],
          "tip": "Quick estimations help you avoid over-engineering or underestimating your architecture."
        },
        "hld": {
          "title": "3. High-Level Design (HLD)",
          "description": "Sketch out the system architecture and data flow.",
          "items": [
            "Identify core modules (e.g., user service, feed service, authentication)",
            "Map interactions between components",
            "Define external dependencies (e.g., third-party APIs)",
            "Choose foundational technologies (databases, frameworks, hosting)"
          ]
        },
        "dataModeling": {
          "title": "4. Data Modeling & API Design",
          "description": "Define the internal and external interfaces.",
          "items": [
            "Database Design: Choose data models, schema, indexing, partitioning",
            "API Design: Define RESTful or RPC endpoints, contracts, authentication"
          ],
          "examples": [
            "POST /tweet → creates a tweet",
            "GET /timeline → fetches a user's feed"
          ]
        },
        "detailedDesign": {
          "title": "5. Detailed Design & Component Deep Dive",
          "description": "Zoom into each service or module.",
          "items": [
            "Define responsibilities, inputs/outputs, failure modes",
            "Apply caching, replication, queuing, and load balancing",
            "Ensure each component meets its NFRs (availability, security, observability)"
          ]
        },
        "bottlenecks": {
          "title": "6. Bottlenecks, Trade-offs & Failure Points",
          "description": "No design is perfect. Analyze risks and justify decisions.",
          "items": [
            "Bottlenecks: Which parts will stress first?",
            "Failure Points: Where is the system vulnerable?"
          ],
          "tradeoffs": {
            "title": "Trade-offs:",
            "items": [
              "Consistency vs. availability (CAP theorem)",
              "Cost vs. latency",
              "Simplicity vs. extensibility"
            ]
          },
          "warning": "Always document trade-offs and fallback plans."
        },
        "review": {
          "title": "7. Review, Validate & Iterate",
          "description": "System design is a living process.",
          "items": [
            "Explain your design to colleagues or stakeholders",
            "Use diagrams to support communication",
            "Iterate based on feedback and testing (load tests, chaos tests)",
            "Monitor and adjust in production"
          ]
        }
      }
    },
    "conclusion": {
      "title": "Conclusion",
      "paragraph1": "Designing robust, scalable, and maintainable systems is both a technical discipline and a creative art. It demands foresight, collaboration, and structured problem-solving.",
      "paragraph2": "By breaking down the process, from identifying requirements and estimating scale to architecting components and validating decisions, you create systems that can gracefully scale, recover from failures, and adapt to change.",
      "paragraph3": "Whether you're tackling a small feature or building a global platform, the mindset and tools of system design remain the same: clarity, resilience, and purpose.",
      "quote": "Mastering system design is not about memorizing patterns, it's about applying principles to real-world problems with context-aware judgment."
    }
  },
  "content": {
    "httpGrpc": {
      "title": "HTTP vs gRPC",
      "description": "HTTP and gRPC are communication protocols for distributed systems, each with distinct characteristics, performance profiles, and use cases for different architectural requirements.",
      "learningTip": "Compare HTTP to sending postcards (human-readable, works everywhere) and gRPC to sending packages with tracking numbers (efficient, structured, but needs special handling). Practice explaining when you'd choose each by thinking about different communication needs in daily life.",
      "keyPoints": [
        "Choose appropriate protocol based on performance and compatibility needs",
        "Consider development complexity and ecosystem support",
        "Evaluate network efficiency and payload size requirements",
        "Balance human readability with machine efficiency",
        "Plan for debugging, monitoring, and operational requirements"
      ],
      "httpCharacteristics": [
        "Text-based protocol with human-readable format",
        "Stateless request-response model with wide browser support",
        "Extensive tooling and debugging capabilities",
        "RESTful design patterns and JSON/XML payloads",
        "Built-in caching mechanisms and CDN compatibility"
      ],
      "grpcCharacteristics": [
        "Binary protocol with Protocol Buffers serialization",
        "Bidirectional streaming and multiplexing support",
        "Strong typing with code generation from schemas",
        "HTTP/2 based with connection reuse and compression",
        "Built-in authentication, load balancing, and health checking"
      ],
      "httpUseCases": [
        "Public APIs requiring broad compatibility",
        "Web applications with browser-based clients",
        "RESTful services with CRUD operations",
        "Systems requiring extensive debugging and monitoring",
        "Integration with existing HTTP infrastructure"
      ],
      "grpcUseCases": [
        "High-performance microservices communication",
        "Real-time applications requiring streaming",
        "Internal APIs with controlled client environments",
        "Systems requiring strong typing and code generation",
        "Polyglot environments with multiple programming languages"
      ],
      "performanceComparison": [
        "gRPC: Lower latency, smaller payload sizes, better throughput",
        "HTTP: Higher latency, larger payloads, simpler debugging",
        "gRPC: Better for high-frequency internal communication",
        "HTTP: Better for public APIs and web integration",
        "gRPC: Requires HTTP/2 support, HTTP: Works with HTTP/1.1"
      ]
    },
    "restGraphql": {
      "title": "REST vs GraphQL",
      "description": "REST and GraphQL are API design paradigms offering different approaches to data fetching, with REST providing resource-based endpoints and GraphQL enabling flexible query-driven data access.",
      "learningTip": "Think of REST like a restaurant menu with fixed meals (endpoints) and GraphQL like a buffet where you pick exactly what you want. Practice designing both approaches for a simple blog API to understand when the flexibility of GraphQL is worth the added complexity."
    }
  }
}
